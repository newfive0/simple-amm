import { ethers } from 'ethers';
import {
  AMMPool__factory,
  Token__factory,
} from '../../artifacts/typechain-types';

interface ContractAddresses {
  tokenAddress: string;
  ammPoolAddress: string;
}

interface PoolState {
  ethReserve: bigint;
  tokenReserve: bigint;
  totalSupply: bigint;
}

/**
 * ContractManipulator provides direct contract interaction capabilities for E2E testing
 * using TypeChain generated types, similar to how the frontend interacts with contracts.
 */
export class ContractManipulator {
  private provider: ethers.JsonRpcProvider;
  private wallet: ethers.Wallet;
  private contracts: ContractAddresses;

  constructor() {
    // Connect to local Hardhat network
    this.provider = new ethers.JsonRpcProvider('http://localhost:8545');

    // Use a test private key (this should be one of Hardhat's default accounts)
    // Account #1: 0x70997970c51812dc3a010c7d01b50e0d17dc79c8
    this.wallet = new ethers.Wallet(
      '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d',
      this.provider
    );

    // Get contract addresses from environment
    this.contracts = this.getContractAddresses();
  }

  private getContractAddresses(): ContractAddresses {
    // Read from the environment file generated by copy-artifacts
    // These values are set when contracts are deployed and artifacts are copied
    const tokenAddress =
      process.env.VITE_TOKEN_ADDRESS ||
      '0x5FbDB2315678afecb367f032d93F642f64180aa3';
    const ammPoolAddress =
      process.env.VITE_AMM_POOL_ADDRESS ||
      '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0';

    if (!tokenAddress || !ammPoolAddress) {
      throw new Error(
        'Contract addresses not found. Ensure contracts are deployed and artifacts are copied. ' +
          'Run: nx copy-artifacts contracts'
      );
    }

    return { tokenAddress, ammPoolAddress };
  }

  /**
   * Get current pool state (reserves and total supply)
   */
  async getPoolState(): Promise<PoolState> {
    const ammPool = AMMPool__factory.connect(
      this.contracts.ammPoolAddress,
      this.provider
    );

    const [ethReserve, tokenReserve, totalSupply] = await Promise.all([
      ammPool.reserveETH(),
      ammPool.reserveSimplest(),
      ammPool.totalLPTokens(),
    ]);

    return {
      ethReserve,
      tokenReserve,
      totalSupply,
    };
  }

  /**
   * Add liquidity with string amounts (convenience method for tests)
   */
  async addLiquidity(ethAmount: string, tokenAmount: string): Promise<void> {
    const ethAmountWei = BigInt(parseFloat(ethAmount) * 1e18);
    const tokenAmountWei = BigInt(parseFloat(tokenAmount) * 1e18);
    await this.manipulatePoolRatio(ethAmountWei, tokenAmountWei);
  }

  /**
   * Manipulate pool state by adding large amounts of liquidity to create specific ratios
   * This is useful for testing slippage scenarios or specific pool conditions
   */
  async manipulatePoolRatio(
    ethAmount: bigint,
    tokenAmount: bigint
  ): Promise<void> {
    const ammPool = AMMPool__factory.connect(
      this.contracts.ammPoolAddress,
      this.wallet
    );
    const token = Token__factory.connect(
      this.contracts.tokenAddress,
      this.wallet
    );

    // First check if we need to mint more tokens to the test account
    const balance = await token.balanceOf(this.wallet.address);
    if (balance < tokenAmount) {
      // Mint additional tokens to the test account (assuming Token contract allows minting)
      const mintAmount = tokenAmount - balance;
      await this.mintTokensToAccount(this.wallet.address, mintAmount);
    }

    // Approve token spending
    const ammPoolAddress = await ammPool.getAddress();
    const approveTx = await token.approve(ammPoolAddress, tokenAmount);
    await approveTx.wait();

    // Get expected LP tokens (no slippage protection for manipulation)
    const expectedLPTokens = await ammPool.getLiquidityOutput(
      tokenAmount,
      ethAmount
    );

    // Add liquidity with minimal slippage protection
    const minLPTokens = (expectedLPTokens * BigInt(995)) / BigInt(1000); // 0.5% slippage

    const addLiquidityTx = await ammPool.addLiquidity(
      tokenAmount,
      minLPTokens,
      {
        value: ethAmount,
      }
    );
    await addLiquidityTx.wait();
  }

  /**
   * Mint tokens to a specific account (for testing purposes)
   * Note: This assumes the Token contract has a mint function accessible by the test account
   */
  private async mintTokensToAccount(
    account: string,
    amount: bigint
  ): Promise<void> {
    const token = Token__factory.connect(
      this.contracts.tokenAddress,
      this.wallet
    );

    try {
      // Try to mint tokens - this might fail if the account doesn't have minting privileges
      const mintTx = await token.mint(account, amount);
      await mintTx.wait();
    } catch {
      // If minting fails, try to transfer from the deployer account (account #0)
      const deployerWallet = new ethers.Wallet(
        '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
        this.provider
      );
      const tokenAsDeployer = Token__factory.connect(
        this.contracts.tokenAddress,
        deployerWallet
      );

      const transferTx = await tokenAsDeployer.transfer(account, amount);
      await transferTx.wait();
    }
  }

  /**
   * Reset the local Hardhat network state to clean slate
   */
  async resetNetwork(): Promise<void> {
    await this.provider.send('hardhat_reset', []);
  }

  /**
   * Get account balance (ETH and Token)
   */
  async getAccountBalance(
    account: string
  ): Promise<{ eth: bigint; token: bigint }> {
    const token = Token__factory.connect(
      this.contracts.tokenAddress,
      this.provider
    );

    const [ethBalance, tokenBalance] = await Promise.all([
      this.provider.getBalance(account),
      token.balanceOf(account),
    ]);

    return {
      eth: ethBalance,
      token: tokenBalance,
    };
  }

  /**
   * Perform a direct swap operation (useful for setting up test scenarios)
   */
  async performSwap(ethForToken: boolean, inputAmount: bigint): Promise<void> {
    const ammPool = AMMPool__factory.connect(
      this.contracts.ammPoolAddress,
      this.wallet
    );

    if (ethForToken) {
      // ETH → Token swap
      // For ETH input, we need to pass ETH address (zero address)
      const ethAddress = '0x0000000000000000000000000000000000000000';
      const expectedOutput = await ammPool.getSwapOutput(
        ethAddress,
        inputAmount
      );
      const minOutput = (expectedOutput * BigInt(995)) / BigInt(1000); // 0.5% slippage

      const swapTx = await ammPool.swap(ethAddress, inputAmount, minOutput, {
        value: inputAmount,
      });
      await swapTx.wait();
    } else {
      // Token → ETH swap
      const token = Token__factory.connect(
        this.contracts.tokenAddress,
        this.wallet
      );

      // Approve token spending
      const ammPoolAddress = await ammPool.getAddress();
      const approveTx = await token.approve(ammPoolAddress, inputAmount);
      await approveTx.wait();

      const expectedOutput = await ammPool.getSwapOutput(
        this.contracts.tokenAddress,
        inputAmount
      );
      const minOutput = (expectedOutput * BigInt(995)) / BigInt(1000); // 0.5% slippage

      const swapTx = await ammPool.swap(
        this.contracts.tokenAddress,
        inputAmount,
        minOutput
      );
      await swapTx.wait();
    }
  }
}
